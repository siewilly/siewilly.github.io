---
title: AIS3 pre-exam 2025
date: 2025-07-11 13:32:32
tags:
  - AIS3
categories: è³‡å®‰
cover: /img/ais3.webp
---
# å‰è¨€

é€™æ˜¯æˆ‘çš„ç¬¬ä¸€æ¬¡CTF
æ‰“å¾—å¾ˆçˆ›writeupä¹Ÿå¯«å¾—å¾ˆçˆ›
~~ç‚ºäº†å„ä½çš„çœ¼ç›è‘—æƒ³è«‹ä¸è¦ç¹¼çºŒå¾€ä¸‹çœ‹~~
<!-- more -->
# web
## tomorin db
### é¡Œç›®è§€å¯Ÿ
é¦–å…ˆé»é€²é¡Œç›®æä¾›çš„ç¶²å€ http://chals1.ais3.org:30000/ :
![](/img/tomorin.webp)
å¯ä»¥çœ‹åˆ°å…¶ä¸­æœ‰å››å€‹æª”æ¡ˆ
- cute.jpg
- flag
- is.jpg
- tomorin.jpg

å…¶ä¸­ä¸‰å€‹æ˜¯åœ–ç‰‡,**ä½†flagé»é€²å»æœƒè·³è½‰åˆ°[MyGO!!!!!çš„è¿æ—¥ç®‹ç§‹](https://www.youtube.com/watch?v=lQuWN0biOBU)** ~~åˆåœ¨GO~~
![](/img/MyGO.webp)


### æ¼æ´åˆ†æ
æ—¢ç„¶flagæ–‡ä»¶ç¢ºå¯¦å­˜åœ¨,ä½†æ˜¯/flagè·¯å¾‘åšäº†ç‰¹æ®Šè™•ç†,é‚£æˆ‘å€‘å¯ä»¥å˜—è©¦ç¹é/flagé€™å€‹è·¯å¾‘
### ç¹éæ€è·¯
ç¶“éå˜—è©¦,æˆ‘ç™¼ç¾å¦‚æœæˆ‘å€‘ç”¨URLç·¨ç¢¼ **(%2f)** å†åŠ ä¸Šflagå°±ä¸æœƒè¢«è½‰å€
æ‰€ä»¥æˆ‘åœ¨æ ¹ç¶²å€å¾ŒåŠ ä¸Š ***/%2fflag***
![](/img/æˆåŠŸè¨ªå•.webp)

æˆ‘å€‘å°±å¯ä»¥å¾—åˆ°flag
```
AIS3{G01ang_H2v3_a_c0O1_way!!!_Us3ing_C0NN3ct_M3Th07_L0l@T0m0r1n_1s_cute_D0_yo7_L0ve_t0MoRIN?} 
```
## Login Screen 1
### é é¢åˆ†æ
é»é€²ç¶²é å¾Œæˆ‘å€‘çœ‹åˆ°äº†ä¸€å€‹ç™»å…¥ä»‹é¢
![](/img/ç™»å…¥ç•«é¢.webp)
åŒ…å«:
- Username è¼¸å…¥æ¡†
- Password è¼¸å…¥æ¡†
- Login æŒ‰éˆ•
### æ³¨å…¥æ”»æ“Š
![](/img/FLAGG.webp)
æˆ‘å€‘å°±å¾—åˆ°FLAG:
```
AIS3{1.Es55y_SQL_1nJ3ct10n_w1th_2fa_IuABDADGeP0}
```
# misc
## Ramen CTF
é€™é¡Œæ˜¯æˆ‘è¦ºå¾—æœ€æœ‰è¶£çš„
### é¡Œç›®è§€å¯Ÿ
ä»–çµ¦æˆ‘å€‘äº†ä¸€å¼µåœ–ç‰‡
![](/img/chal.jpg)
è£¡é¢æœ‰åƒ¹å€¼çš„åªæœ‰é‚£å¼µç™¼ç¥¨,æˆ‘å°±æƒ³åˆ°ç”¨ç™¼ç¥¨çš„è³‡è¨Šæ˜¯ä¸æ˜¯èƒ½æŸ¥åˆ°ä¸€äº›è³‡æ–™
![](/img/ç™¼ç¥¨.jpg)

å¯ä»¥å¾—åˆ°ä»¥ä¸‹è³‡è¨Š:
- å¹³å’Œ....
- MFé–‹é ­
- 2025/04/13çš„ç™¼ç¥¨
- éš¨æ©Ÿç¢¼ 7095
- è³£æ–¹ç·¨è™Ÿ 3478592...

æ¥ä¸‹ä¾†ç”¨QRcodeæƒæç¨‹å¼å¾—çŸ¥:
![](/img/QRcode.webp)
- ç™¼ç¥¨å®Œæ•´è™Ÿç¢¼ MF16879911
- é¤é»æ˜¯è¦æ‹‰éºµ
### åœ°å€å°‹æ‰¾
å°‡ä¸Šé¢çš„è³‡æ–™è¼¸å…¥[è²¡æ”¿éƒ¨é›»å­ç™¼ç¥¨æ•´åˆå¹³å°](https://www.einvoice.nat.gov.tw/portal/btc/audit/btc601w/search)

![](/img/å®Œæ•´è³‡è¨Š.webp)
æˆ‘å€‘å°±å¾—åˆ°äº†åœ°å€,å†æŠŠåœ°å€è¼¸å…¥Google Map
æˆ‘å€‘å¯ä»¥æ‰¾åˆ°ä¸€å®¶ **æ¨‚å±±æº«æ³‰æ‹‰éºµ**
![](/img/Map.webp)

æˆ‘å€‘å°±å¯ä»¥å¾—åˆ°Flag
```
AIS3{æ¨‚å±±æº«æ³‰æ‹‰éºµ:è¦æ‹‰éºµ}
```
## AIS3 Tiny Server - Web / Misc
é¦–å…ˆé»é€²é¡Œç›®æä¾›çš„ç¶²å€ç”¨å¥½tokenä¹‹å¾Œ
æˆ‘å€‘æœƒä¾†åˆ° http://chals1.ais3.org:20096/index.html
![](/img/Tiny-server.webp)
æˆ‘å°±æŠŠå¸¸è¦‹çš„éš±è—è·¯å¾‘éƒ½åŠ ä¸Šå»,å¤šæ¬¡å˜—è©¦å¾Œç™¼ç¾**åŠ //å¯ä»¥å«å‡ºæ–‡ä»¶ç›®éŒ„**
![](/img/ç›®éŒ„.webp)
è£¡é¢æœ‰å¾ˆå¤šæª”æ¡ˆ,æˆ‘å°±é»äº†æª”åæœ‰flagçš„**readable_flag_jkO47trw1ctKlOIFC7smx7hivqoCPL8Y**
![](/img/FLAG.webp)
æˆ‘å€‘å°±å¾—åˆ°äº†flag:
```
AIS3{tInY_we8_53Rv3R_wi7H_fILe_8R0Ws1nG_AS_@_FeAtURe}
```
## Welcome
### æˆ‘å°±ç›´æ¥æ‰“ä¸Šå»owo
![](/img/welcome.webp)
# crypto
## SlowECDSA

çœ‹åˆ°é¡Œç›®å¾Œï¼Œæˆ‘ç™¼ç¾é€™å°±æ˜¯ä¸€å€‹ç¶“å…¸çš„LCGæ”»æ“Šé¡Œã€‚ECDSA çš„å®‰å…¨æ€§å®Œå…¨ä¾è³´æ–¼éš¨æ©Ÿæ•¸ k çš„ä¸å¯é æ¸¬æ€§ï¼Œå¦‚æœæœå‹™å™¨ç”¨ LCG ä¾†ç”Ÿæˆé€™äº›éš¨æ©Ÿæ•¸ï¼Œé‚£å°±ä¸é›£äº†

### **æ”¶é›†ç¯„æœ¬**
æ—¢ç„¶æœå‹™å™¨æä¾› `get_example` åŠŸèƒ½ï¼Œæˆ‘å°±å…ˆèª¿ç”¨å…©æ¬¡ï¼Œç²å–å…©å€‹ä¸åŒç°½åã€‚é€™æ¨£æˆ‘å°±èƒ½å¾—åˆ°ä½¿ç”¨é€£çºŒ LCG éš¨æ©Ÿæ•¸çš„ç°½åå°

### **æ•¸å­¸é—œä¿‚**
æ ¹æ“šPerplexityçš„è³‡æ–™:
ECDSA ç°½åå…¬å¼æ˜¯ï¼š
$$ s = k^{-1} \times (h + r \times d) \bmod n $$

å¦‚æœ kâ‚ å’Œ kâ‚‚ æœ‰ç·šæ€§é—œä¿‚ï¼škâ‚‚ = (a Ã— kâ‚ + c) mod nï¼Œé‚£æˆ‘å€‘å°±èƒ½å»ºä¸€å€‹é—œæ–¼ d çš„æ–¹ç¨‹å¼

## **æ±‚è§£**
å¾å…©å€‹ç°½åçš„é—œä¿‚ä¸­ï¼Œå¯ä»¥æ¨å°å‡ºï¼š
$$ sâ‚‚^{-1} \times (h + râ‚‚ \times d) \equiv a \times sâ‚^{-1} \times (h + râ‚ \times d) + c \pmod{n} $$

è§£é€™å€‹ç·šæ€§æ–¹ç¨‹å°±èƒ½å¾—åˆ° dã€‚

### **é æ¸¬**
æœ‰äº†ç§é‘°ï¼Œæˆ‘å€‘å°±èƒ½åæ¨å‡ºçœŸæ­£çš„ kâ‚ï¼Œç„¶å¾Œåˆ©ç”¨ LCG çš„ç·šæ€§æ€§è³ªé æ¸¬ kâ‚ƒã€‚

### **å½é€ ç°½å**
ç”¨é æ¸¬çš„ kâ‚ƒ å’Œå·²çŸ¥çš„ç§é‘°ï¼Œç‚ºç›®æ¨™æ¶ˆæ¯ "give_me_flag" ç”Ÿæˆå®Œå…¨æœ‰æ•ˆçš„ç°½åã€‚

### **æ”»æ“Š**

æˆ‘å«AIå¯«äº†ä¸€å€‹ Python è…³æœ¬ä¾†å¯¦ç¾é€™å€‹æ”»æ“Šï¼š

```python
from pwn import *
from hashlib import sha1
from sage.all import *
import re

# æ©¢åœ“æ›²ç·šåƒæ•¸ (secp256k1)
p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
a_curve = 0
b_curve = 7
n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141

# LCG åƒæ•¸
a = 0x5deece66d
c = 0xb

def get_example_signature(conn):
    """ç²å–ç¤ºä¾‹ç°½å"""
    conn.sendline(b'1')
    response = conn.recvuntil(b'Choice: ').decode()
    
    # è§£æ r å’Œ s å€¼
    r_match = re.search(r'r=0x([0-9a-f]+)', response)
    s_match = re.search(r's=0x([0-9a-f]+)', response)
    
    if r_match and s_match:
        r = int(r_match.group(1), 16)
        s = int(s_match.group(1), 16)
        print(f"[*] Received example: msg='example_msg', r=0x{r:x}, s=0x{s:x}")
        return {'r': r, 's': s}
    else:
        raise ValueError("ç„¡æ³•è§£æç°½å")

def solve_for_private_key(sig1, sig2, h, n, a, c):
    """æ±‚è§£ç§é‘°"""
    r1, s1 = sig1['r'], sig1['s']
    r2, s2 = sig2['r'], sig2['s']
    
    # å»ºç«‹ç·šæ€§åŒé¤˜æ–¹ç¨‹æ±‚è§£ç§é‘°
    # s2^-1 * (h + r2 * d) â‰¡ a * s1^-1 * (h + r1 * d) + c (mod n)
    
    s1_inv = pow(s1, -1, n)
    s2_inv = pow(s2, -1, n)
    
    # é‡æ–°æ•´ç†æ–¹ç¨‹å¼
    # s2_inv * h + s2_inv * r2 * d â‰¡ a * s1_inv * h + a * s1_inv * r1 * d + c (mod n)
    # (s2_inv * r2 - a * s1_inv * r1) * d â‰¡ a * s1_inv * h - s2_inv * h + c (mod n)
    
    coeff_d = (s2_inv * r2 - a * s1_inv * r1) % n
    rhs = (a * s1_inv * h - s2_inv * h + c) % n
    
    # æ±‚è§£ d
    coeff_d_inv = pow(coeff_d, -1, n)
    d = (coeff_d_inv * rhs) % n
    
    return d

def predict_next_k(sk, sig1, h, n, a, c):
    """é æ¸¬ä¸‹ä¸€å€‹éš¨æ©Ÿæ•¸"""
    r1, s1 = sig1['r'], sig1['s']
    
    # è¨ˆç®—å¯¦éš›çš„ k1
    s1_inv = pow(s1, -1, n)
    k1_actual = (s1_inv * (h + r1 * sk)) % n
    print(f"[*] Calculated k1_actual: 0x{k1_actual:x}")
    
    # è¨ˆç®— k2
    k2_actual = (a * k1_actual + c) % n
    
    # é æ¸¬ k3
    k3_for_flag = (a * k2_actual + c) % n
    print(f"[*] Predicted k3 for flag signing: 0x{k3_for_flag:x}")
    
    return k3_for_flag

def forge_signature(k, h, sk, G, n):
    """å½é€ ç°½å"""
    # è¨ˆç®— r
    point = k * G
    r = point.xy()[0] % n
    
    # è¨ˆç®— s
    k_inv = pow(k, -1, n)
    s = (k_inv * (h + r * sk)) % n
    
    return r, s

def main():
    # é€£æ¥åˆ°æœå‹™å™¨
    print("[+] Opening connection to chals1.ais3.org on port 19000: Done")
    conn = remote('chals1.ais3.org', 19000)
    
    # è·³éåˆå§‹è¨Šæ¯
    conn.recvuntil(b'Choice: ')
    
    # ç²å–ç¬¬ä¸€å€‹ç¤ºä¾‹ç°½å
    print("[*] Getting first example signature...")
    example1 = get_example_signature(conn)
    
    # ç²å–ç¬¬äºŒå€‹ç¤ºä¾‹ç°½å
    print("[*] Getting second example signature...")
    example2 = get_example_signature(conn)
    
    # å»ºç«‹æ©¢åœ“æ›²ç·š
    E = EllipticCurve(GF(p), [a_curve, b_curve])
    G = E(0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,
          0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8)
    
    # è¨ˆç®— example_msg çš„å“ˆå¸Œ
    h_ex = int.from_bytes(sha1(b"example_msg").digest(), 'big')
    print(f"[*] h_ex (for 'example_msg') = 0x{h_ex:x}")
    
    # æ±‚è§£ç§é‘°
    sk = solve_for_private_key(example1, example2, h_ex, n, a, c)
    print(f"[+] Recovered private key (sk): 0x{sk:x}")
    
    # é æ¸¬ä¸‹ä¸€å€‹éš¨æ©Ÿæ•¸
    k3_predicted = predict_next_k(sk, example1, h_ex, n, a, c)
    
    # è¨ˆç®— give_me_flag çš„å“ˆå¸Œ
    h_flag = int.from_bytes(sha1(b"give_me_flag").digest(), 'big')
    print(f"[*] h_flag (for 'give_me_flag') = 0x{h_flag:x}")
    
    # å½é€ ç°½å
    r_flag, s_flag = forge_signature(k3_predicted, h_flag, sk, G, n)
    print(f"[+] Forged signature for 'give_me_flag': r=0x{r_flag:x}, s=0x{s_flag:x}")
    
    # æäº¤å½é€ çš„ç°½å
    print("[*] Sending forged signature to verify...")
    conn.sendline(b'2')
    conn.sendline(hex(r_flag)[2:].encode())
    conn.sendline(hex(s_flag)[2:].encode())
    
    # æ¥æ”¶å›æ‡‰
    print("[*] Server response:")
    response = conn.recvall().decode()
    print(response)
    
    # é—œé–‰é€£æ¥
    conn.close()

if __name__ == "__main__":
    main()
```

åŸ·è¡Œå¾Œ,æˆ‘å€‘å¾—åˆ°äº†Flagï¼š
![](/img/response.webp)
```
AIS3{Aff1n3_nounc3s_c@N_bE_broke_ezily...}
```

## Stream
æ ¹æ“šé¡Œç›®æä¾›çš„pythonç¨‹å¼,æˆ‘å€‘çœ‹åˆ°äº†é€™å€‹åŠ å¯†æ–¹æ¡ˆçš„ç¼ºé™·:
**ç•¶æ˜æ–‡ç›¸å°æ–¼å¯†é‘°è¼ƒå°æ™‚ï¼ŒXOR é‹ç®—çš„çµæœä¸»è¦ç”±å¯†é‘°æ±ºå®š**
æ‰€ä»¥æˆ‘å€‘å¯ä»¥åˆ©ç”¨æ•¸å­¸é—œä¿‚é€†å‘æ”»æ“Š
![](/img/ç¼ºé™·.webp)
### **æ€è·¯**
ç¾åœ¨æˆ‘å€‘çŸ¥é“åŠ å¯†å…¬å¼ç‚º:
```
encrypted_int = flag_int âŠ• (rand_numÂ²)
```
ç•¶ flag_int é å°æ–¼ rand_numÂ² æ™‚ï¼Œæˆ‘å€‘æœ‰:
```
encrypted_int â‰ˆ rand_numÂ²
```
é‚£æˆ‘å€‘å°±å¯ä»¥é€†æ¨flagäº†
### **æ”»æ“Š**
æˆ‘å€‘å…ˆè¨ˆç®—è¿‘ä¼¼éš¨æ©Ÿæ•¸:
```python
approx_rand_num = math.isqrt(encrypted_int)
```
å†æœç´¢åç§»äº®:
```python
for offset in range(-search_width, search_width + 1):
    rand_num_candidate = approx_rand_num + offset
```
æ¥ä¸‹ä¾†å°æ¯å€‹å€™é¸éš¨æ©Ÿæ•¸ï¼Œè¨ˆç®—å…¶å¹³æ–¹ä¸¦å˜—è©¦è§£å¯†:
```python
key_squared = rand_num_candidate ** 2
flag_candidate = encrypted_int ^ key_squared
```
åŸºæœ¬éæ¿¾:
```python
# æ’é™¤ç„¡æ•ˆçµæœ
if flag_candidate == 0:
    continue

# æª¢æŸ¥é•·åº¦åˆç†æ€§
num_bits = flag_candidate.bit_length()
byte_len = (num_bits + 7) // 8
if not (5 < byte_len < 80):
    continue
```
è½‰æ›ç‚ºå­—ä¸²
```python
def int_to_bytes(n: int) -> bytes:
    if n == 0:
        return b'\x00'
    byte_length = (n.bit_length() + 7) // 8
    return n.to_bytes(byte_length, 'big')

flag_bytes_candidate = int_to_bytes(flag_candidate)
```
æœ€å¾Œä¸€éƒ¨,è§£ç¢¼
```python
    try:
        potential_flag = flag_bytes_candidate.decode('ascii')
        
        # æª¢æŸ¥ AIS3 æ ¼å¼
        if (potential_flag.startswith('AIS3{') and 
            potential_flag.endswith('}') and 
            potential_flag.isprintable()):
            
            print(f"[æˆåŠŸ] æ‰¾åˆ° AIS3 flagï¼Œoffset: {offset}")
            print(f"å€™é¸ rand_num: {hex(rand_num_candidate)}")
            print(f"Flag bytes: {flag_bytes_candidate}")
            print(f"è§£å¯†çµæœ: {potential_flag}")
            found_flag = True
            break
            
    except UnicodeDecodeError
        continue
    except Exception as e:
        print(f"è™•ç† offset {offset} æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")

if not found_flag:
    print(f"\nåœ¨ç¯„åœ [{-search_width}, {search_width}] å…§æœªæ‰¾åˆ°æœ‰æ•ˆ flag")
    print("å»ºè­°å¢åŠ  search_width æˆ–æª¢æŸ¥åŠ å¯†å‡è¨­")
```
é‹è¡Œå¾Œæˆ‘å€‘å°±æ‹¿åˆ°äº†flag:
![](/img/print.webp)
```
AIS3{no_more_junks...plz}
```
## Hill
ç³»çµ±ä½¿ç”¨å…©å€‹çŸ©é™£ A å’Œ Bï¼š

- ç¬¬ä¸€å€‹åˆ†çµ„ï¼šcâ‚€ = A Ã— mâ‚€

- å¾ŒçºŒåˆ†çµ„ï¼šcáµ¢ = A Ã— máµ¢ + B Ã— máµ¢â‚‹â‚
### **æ€è·¯**
(ä¼ºæœå™¨åªå…è¨±ä¸€æ¬¡ `input()`)
æˆ‘éœ€è¦ä¸€å€‹ç‰¹æ®Šçš„è¼¸å…¥åºåˆ—ä¾†åŒæ™‚æ¢å¾© A å’Œ B çŸ©é™£ã€‚æˆ‘æƒ³åˆ°ç”¨æ¨™æº–åŸºå‘é‡:
```è¼‰è· = [eâ‚€, 0, eâ‚, 0, eâ‚‚, 0, ..., eâ‚‡, 0]```

ç•¶æœå‹™å™¨è™•ç†é€™å€‹è¼‰è·æ™‚ï¼š

- câ‚€ = A Ã— eâ‚€  å¾—åˆ° A çš„ 0 
- câ‚ = A Ã— 0 + B Ã— eâ‚€  å¾—åˆ° B çš„ 0 
- câ‚‚ = A Ã— eâ‚  å¾—åˆ° A çš„ 1 
- ä»¥æ­¤é¡æ¨...

æ¢å¾© A å’Œ B å¾Œï¼Œè¨ˆç®— A çš„é€†çŸ©é™£ï¼Œç„¶å¾Œé€†å‘è§£å¯†ç›®æ¨™ FLAG
### **æ”»æ“Š**
```python
import numpy as np
from sympy import Matrix
from pwn import *
import re

# è¨­å®šåƒæ•¸
HOST = 'chals1.ais3.org'
PORT = 18000
n = 8  # å€å¡Šå¤§å°å’ŒçŸ©é™£ç¶­åº¦
p_mod = 251  # æ¨¡æ•¸

def parse_block_line(line):
    """ä½¿ç”¨æ­£å‰‡è¡¨é”å¼è§£æåŒ…å«8å€‹æ•¸å­—çš„è¡Œ"""
    if isinstance(line, bytes):
        line = line.decode().strip()
    else:
        line = line.strip()
    
    # ä½¿ç”¨æ­£å‰‡è¡¨é”å¼æå–æ‰€æœ‰æ•¸å­—
    nums = re.findall(r'\d+', line)
    if len(nums) == 8:
        return np.array([int(x) for x in nums])
    else:
        return None

def inv_mod(matrix, mod):
    """è¨ˆç®—çŸ©é™£çš„æ¨¡é€†"""
    A_matrix = Matrix(matrix)
    A_inv = np.array(A_matrix.inv_mod(mod), dtype=int)
    return A_inv

def solve():
    r = remote(HOST, PORT)
    
    try:
        # 1. å…ˆè®€å–æ‰€æœ‰åˆå§‹è¼¸å‡º
        print("[*] Reading all initial output...")
        all_lines = []
        
        try:
            while True:
                line = r.recvline(timeout=2)
                if not line:
                    break
                decoded_line = line.decode().strip()
                all_lines.append(decoded_line)
                print(f"[DEBUG] Received: '{decoded_line}'")
                
                # å¦‚æœçœ‹åˆ°è¼¸å…¥æç¤ºå°±åœæ­¢
                if any(keyword in decoded_line.lower() for keyword in ['input', 'enter', 'message']):
                    break
        except EOFError:
            print("[DEBUG] EOF reached")
        
        # 2. å¾æ‰€æœ‰è¡Œä¸­è§£æç›®æ¨™ FLAG
        print("[*] Parsing target flag from received lines...")
        C_target_flag = []
        flag_started = False
        
        for line in all_lines:
            print(f"[DEBUG] Processing line: '{line}'")
            
            # æª¢æŸ¥æ˜¯å¦é–‹å§‹ flag å€åŸŸ
            if "encrypted flag" in line.lower():
                flag_started = True
                continue
            
            # å¦‚æœé‡åˆ°è¼¸å…¥æç¤ºå°±åœæ­¢è§£æ flag
            if any(keyword in line.lower() for keyword in ['input', 'enter', 'message']):
                break
            
            # å¦‚æœåœ¨ flag å€åŸŸï¼Œå˜—è©¦è§£ææ•¸å­—
            if flag_started and line.strip():
                block = parse_block_line(line)
                if block is not None:
                    C_target_flag.append(block)
                    print(f"[DEBUG] Parsed flag block {len(C_target_flag)}: {list(block)}")
        
        print(f"[*] Target flag has {len(C_target_flag)} blocks")
        
        if len(C_target_flag) == 0:
            print("[ERROR] Failed to parse target flag")
            return
        
        # 3. æ§‹é€  payload M_payload
        print("[*] Constructing payload...")
        M_payload_blocks = []
        for i in range(n):
            e_i = np.zeros(n, dtype=int)
            e_i[i] = 1
            M_payload_blocks.append(e_i)  # p_{2i} = e_i
            M_payload_blocks.append(np.zeros(n, dtype=int))  # p_{2i+1} = 0
        
        payload_bytes_list = []
        for block in M_payload_blocks:
            payload_bytes_list.extend(list(block))
        final_payload = bytes(payload_bytes_list)
        
        print(f"[DEBUG] Payload length: {len(final_payload)} bytes")
        
        # 4. ç™¼é€ payload
        print("[*] Sending payload...")
        r.sendline(final_payload)
        
        # 5. æ¥æ”¶ 2n å€‹å¯†æ–‡å€å¡Š (C_response)
        print("[*] Receiving response blocks...")
        C_response = []
        
        try:
            while len(C_response) < 2 * n:
                line = r.recvline(timeout=3)
                if not line:
                    break
                
                decoded_line = line.decode().strip()
                print(f"[DEBUG] Response line: '{decoded_line}'")
                
                if not decoded_line:
                    continue
                
                block = parse_block_line(decoded_line)
                if block is not None:
                    C_response.append(block)
                    print(f"[DEBUG] Received response block {len(C_response)}: {list(block)}")
                    
        except EOFError:
            print("[DEBUG] EOF while receiving response")
        
        if len(C_response) < 2 * n:
            print(f"[ERROR] Expected {2*n} response blocks, got {len(C_response)}")
            return
        
        # 6. å¾ C_response æå– A å’Œ B
        print("[*] Recovering matrices A and B...")
        A_recovered_cols = []
        B_recovered_cols = []
        
        for i in range(n):
            A_recovered_cols.append(C_response[2*i])
            B_recovered_cols.append(C_response[2*i+1])
        
        A_recovered = np.array(A_recovered_cols).T % p_mod
        B_recovered = np.array(B_recovered_cols).T % p_mod
        
        print("[*] Recovered matrix A:")
        print(A_recovered)
        
        # 7. è¨ˆç®— A çš„æ¨¡é€†
        print("[*] Calculating inverse of A...")
        A_inv = inv_mod(A_recovered, p_mod)
        print("[+] Calculated A_inv successfully")
        
        # 8. è§£å¯† C_target_flag
        print(f"[*] Decrypting {len(C_target_flag)} target flag blocks...")
        decrypted_blocks_list = []
        
        # è§£å¯†ç¬¬ä¸€å€‹å€å¡Š
        block_0 = (A_inv @ C_target_flag[0]) % p_mod
        decrypted_blocks_list.append(block_0)
        print(f"[DEBUG] Decrypted target flag block 0: {list(block_0)}")
        
        # è¿´åœˆè§£å¯†å¾ŒçºŒå€å¡Š
        for i in range(1, len(C_target_flag)):
            temp = (C_target_flag[i] - B_recovered @ decrypted_blocks_list[i-1] + p_mod) % p_mod
            block_i = (A_inv @ temp) % p_mod
            decrypted_blocks_list.append(block_i)
            print(f"[DEBUG] Decrypted target flag block {i}: {list(block_i)}")
        
        # 9. çµ„è£ FLAG å­—ä¸²
        flag_bytes = b"".join(bytes(list(block_array)) for block_array in decrypted_blocks_list)
        flag_str = flag_bytes.decode('utf-8', errors='ignore').rstrip('\x00')
        
        print(f"[+] Decrypting all target flag blocks.")
        print(f"[+] FLAG: {flag_str}")
        
    except Exception as e:
        print(f"[ERROR] Attack failed: {e}")
        import traceback
        traceback.print_exc()
    finally:
        r.close()

# ä¸»ç¨‹å¼å…¥å£
if __name__ == "__main__":
    solve()
```
åŸ·è¡Œå¾Œ,æˆ‘å€‘å¾—åˆ°:
![](/img/FLAGGG.webp)
FLAG:
```AIS3{b451c_h1ll_c1ph3r_15_2_3z_f0r_u5}```
## Happy Happy Factoring 
é€™æ˜¯ä¸€å€‹ç¶“å…¸çš„å¤šç®—æ³•çµ„åˆæ”»æ“Š:
- wiï¼šWilliams' p+1 ç®—æ³•
- poï¼šPollard's p-1 ç®—æ³•
- fp, fqï¼šFermat å› å¼åˆ†è§£æ³•

å…ˆç”¨ Pollard's p-1 æ‰¾åˆ° po,ç§»é™¤ poÂ² å¾Œç”¨ Williams' p+1 æ‰¾åˆ° wi,æœ€å¾Œç”¨ Fermat æ–¹æ³•åˆ†è§£å‰©é¤˜éƒ¨åˆ†

ç²å¾—æ‰€æœ‰å› æ•¸å¾Œè¨ˆç®—æ­æ‹‰å‡½æ•¸ä¸¦è§£å¯†ã€‚
```python
import gmpy2
from collections import Counter

def read_input(filename="output.txt"):
    with open(filename, "r") as f:
        lines = f.read().strip().splitlines()
        n = int(lines[0].split(" = ")[1])
        e = int(lines[1].split(" = ")[1])
        c = int(lines[2].split(" = ")[1])
        return n, e, c

def generate_prime_list():
    return [p for p in range(3, 5000) if gmpy2.is_prime(p)]

def pollard_p_minus_1(n, prime_list):
    a = gmpy2.mpz(2)
    for _ in range(86):
        a = gmpy2.powmod(a, 2, n)
    for p in prime_list:
        for _ in range(85):
            a = gmpy2.powmod(a, p, n)
    return gmpy2.gcd(a - 1, n)

def extract_factor(gcd_val, n, expected_power=1):
    if gcd_val in [1, n]: return None
    if gmpy2.is_prime(gcd_val): return int(gcd_val)
    temp = gcd_val
    factors = []
    for p in [2] + generate_prime_list():
        while temp % p == 0:
            factors.append(p)
            temp //= p
        if temp == 1:
            break
    if temp > 1 and gmpy2.is_prime(temp): factors.append(int(temp))
    counts = Counter(factors)
    for f, count in counts.items():
        if count >= expected_power and gmpy2.is_prime(f):
            return f
    return None

def lucas_V(k, P, N):
    if k == 0: return 2
    if k == 1: return P
    V0, V1 = 2, P
    for bit in bin(k)[3:]:
        if bit == "0":
            V1 = (V0 * V1 - P) % N
            V0 = (V0 * V0 - 2) % N
        else:
            V0 = (V0 * V1 - P) % N
            V1 = (V1 * V1 - 2) % N
    return V1

def williams_p_plus_1(n, prime_list, P=3):
    V = P
    for _ in range(86):
        V = lucas_V(2, V, n)
    for p in prime_list:
        for _ in range(85):
            V = lucas_V(p, V, n)
    return gmpy2.gcd(V - 2, n)

def fermat(n, max_iter=200_000_000):
    a = gmpy2.isqrt(n) + 1
    for i in range(max_iter):
        b2 = a * a - n
        b = gmpy2.isqrt(b2)
        if b * b == b2:
            return int(a + b), int(a - b)
        if i % 1_000_000 == 0 and i > 0:
            print(f"    [Fermat] å˜—è©¦ {i:,} æ¬¡...")
        a += 1
    return None, None

def rsa_decrypt(n, e, c, po, wi, fp, fq):
    phi = po * (po - 1) * (wi - 1) * (fp - 1) * (fq - 1)
    d = gmpy2.invert(e, phi)
    m = gmpy2.powmod(c, d, n)
    flag = int(m).to_bytes((m.bit_length() + 7) // 8, 'big').decode()
    return phi, d, m, flag

def main():
    print("[*] è®€å– RSA å…¬é–‹åƒæ•¸")
    n, e, c = read_input()
    primes = generate_prime_list()

    print("[*] Step 1: Pollard p-1")
    g = pollard_p_minus_1(n, primes)
    po = extract_factor(g, n, expected_power=2)
    if not po: raise Exception("æ‰¾ä¸åˆ° po")
    n1 = n // (po * po)

    print("[*] Step 2: Williams p+1 or fallback")
    wi = None
    for base in [3, 5, 7, 11, 13, 17, 19, 23]:
        g = williams_p_plus_1(n1, primes, base)
        candidate = extract_factor(g, n1)
        if candidate and gmpy2.is_prime(candidate):
            wi = candidate
            break
    if not wi:
        print("[!] Williams p+1 å¤±æ•—ï¼Œæ”¹ç”¨ Fermat")
        f1, f2 = fermat(n1)
        if f1 and gmpy2.is_prime(f1):
            wi, n2 = f1, f2
        elif f2 and gmpy2.is_prime(f2):
            wi, n2 = f2, f1
        else:
            raise Exception("æ‰¾ä¸åˆ° wi")
    else:
        n2 = n1 // wi

    print("[*] Step 3: Fermat åˆ†è§£ fp, fq")
    fp, fq = fermat(n2)
    if fp < fq:
        fp, fq = fq, fp

    print("[*] Step 4: RSA è§£å¯†")
    phi, d, m, flag = rsa_decrypt(n, e, c, po, wi, fp, fq)

    print("\nğŸ‰ è§£å¯†æˆåŠŸï¼ä»¥ä¸‹æ˜¯è©³ç´°è³‡è¨Šï¼š")
    print("\nå·²æ‰¾åˆ°å› å­ï¼š")
    print(f"po = {po}")
    print(f"wi = {wi}")
    print(f"fp = {fp}")
    print(f"fq = {fq}\n")
    print(f"phi_n = {phi}\n")
    print(f"d = {d}")
    print(f"m = {m}")
    print(f"\nğŸš© Flag: {flag}")

if __name__ == "__main__":
    main()

```
![](/img/çµæœ.webp)
æˆ‘å€‘å°±å¾—åˆ°äº†FLAG:
`AIS3{H@ppY_#ap9y_CRypT0_F4(7or1n&~~~}`

# çµå°¾

å¾ˆé«˜èˆˆ,ä½ çœ‹åˆ°é€™è£¡çœ¼ç›é‚„æ²’çæ‰
ä½†ä¸‹é¢æ²’æ±è¥¿äº†,æ‰€ä»¥æˆ‘å€‘ä¸‹æ¬¡è¦‹(?)